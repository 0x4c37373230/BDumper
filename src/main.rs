use {
    nanoid::nanoid,
    pdb::FallibleIterator,
    std::{fs::File, io::Write, process::Command},
    term_painter::{Color::*, ToStyle},
    text_io::read,
    termprogress::prelude::*
};

fn path_exists(path: &str) -> bool {
    std::fs::metadata(path).is_ok()
}

fn main() -> pdb::Result<()> {
    println!(
        "{}",
        BrightRed.paint(
            "
 __   __              __   ___  __
|__) |  \\ |  |  |\\/| |__) |__  |__)
|__) |__/ \\__/  |  | |    |___ |  \\
                                    "
        )
    );
    println!(
        "A .pdb file dumper made in Rust by Luke7720 designed to extract\n\
         function prototypes and RVAs (Relative Virtual Addresses) and\n\
         export them into either text or C++ header files\n"
    );
    let mut pdb_path: String;
    loop {
        println!("{}", Cyan.paint("Input the pdb file path: "));

        pdb_path = read!();

        let file_exists = path_exists(&*pdb_path);

        if file_exists == true {
            break;
        } else {
            println!("{}", Red.paint("File was not found"));
        }
    }

    let mut file_type: String;

    let mut progress = Bar::default();

    loop {
        println!(
            "{}",
            Cyan.paint(
                "Input the output file type ('hpp' for a C++ header; 'txt' for a text file): "
            )
        );

        file_type = read!();

        progress.set_title("Creating file...");
        progress.set_progress(0.2);

        if file_type == "txt" {
            std::fs::File::create("./SymHook.txt").expect("ERROR: Could not create file");
            break;
        } else if file_type == "hpp" {
            std::fs::File::create("SymHook.hpp").expect("ERROR: Could not create file");
            break;
        } else {
            println!("{}", Red.paint("Unknown file type"))
        }
    }

    std::fs::File::create("./temp.txt").expect("ERROR: Could not create file");

    let mut dump_file = std::fs::OpenOptions::new()
        .write(true)
        .append(true)
        .open("./temp.txt")
        .unwrap();

    progress.set_progress(0.3);

    if file_type == "txt" {
        dump_file = std::fs::OpenOptions::new()
            .write(true)
            .append(true)
            .open("./SymHook.txt")
            .unwrap();
    } else if file_type == "hpp" {
        dump_file = std::fs::OpenOptions::new()
            .write(true)
            .append(true)
            .open("./SymHook.hpp")
            .unwrap();
    }

    std::fs::remove_file("./temp.txt")?;

    progress.set_title("Started writing to file...");
    progress.set_progress(0.5);

    write!(
        dump_file,
        "/*###############################################################\
    \nBDS function symbols and RVAs\
    \nFile generated by BDumper, a rust bds pdb dumper made by Luke7720\
    \n###############################################################*/\n"
    )
    .expect("ERROR: Could not write to file");

    let char_list: [char; 53] = [
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',
        's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '_', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',
        'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
    ];

    progress.set_title("Generating file...");
    progress.set_progress(0.6);

    let file_path = File::open(pdb_path)?;
    let mut pdb = pdb::PDB::open(file_path)?;

    progress.set_progress(0.7);

    let symbol_table = pdb.global_symbols()?;
    let address_map = pdb.address_map()?;

    let mut symbols = symbol_table.iter();
    while let Some(symbol) = symbols.next()? {
        match symbol.parse() {
            Ok(pdb::SymbolData::Public(data)) if data.function => {
                let rva = data.offset.to_rva(&address_map).unwrap_or_default();
                if file_type == "txt" {
                    write!(dump_file, "{}\n{}\n\n", data.name, rva)
                        .expect("ERROR: Could not write to file");
                } else if file_type == "hpp" {
                    let fn_id = nanoid!(10, &char_list);
                    write!(
                        dump_file,
                        "//{};\nconstexpr unsigned int {} = {};\n\n",
                        data.name, fn_id, rva
                    )
                    .expect("ERROR: Could not write to file");
                } else {
                    break;
                }
            }
            _ => {}
        }
    }
    progress.set_title("Done");
    progress.set_progress(1.0);
    println!("\n");
    let _system_pause = Command::new("cmd.exe").arg("/c").arg("pause").status();

    Ok(())
}
