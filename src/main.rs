use nanoid::nanoid;
use pdb::FallibleIterator;
use std::fs::File;
use std::io::Write;
use std::process::Command;
use term_painter::{Color::*, ToStyle};
use text_io::read;

fn main() -> pdb::Result<()> {
    println!("{}", Cyan.paint("Input the pdb file path: "));

    let pdb_path: String = read!();

    println!(
        "{}",
        Cyan.paint("Input the output file type ('hpp' for a C++ header; 'txt' for a text file): ")
    );

    let file_type: String = read!();

    if file_type == "txt" {
        std::fs::File::create("./SymHook.txt");
    } else if file_type == "hpp" {
        std::fs::File::create("SymHook.hpp");
    } else {
        panic!("{}", Red.paint("Unknown file type"))
    }
    std::fs::File::create("./temp.txt");

    let mut dump_file = std::fs::OpenOptions::new()
        .write(true)
        .append(true)
        .open("./temp.txt")
        .unwrap();

    if file_type == "txt" {
        dump_file = std::fs::OpenOptions::new()
            .write(true)
            .append(true)
            .open("./SymHook.txt")
            .unwrap();
    } else if file_type == "hpp" {
        dump_file = std::fs::OpenOptions::new()
            .write(true)
            .append(true)
            .open("./SymHook.hpp")
            .unwrap();
    }
    std::fs::remove_file("./temp.txt")?;

    write!(
        dump_file,
        "/*###############################################################\
    \nBDS function symbols and RVAs\
    \nFile generated by BDumper, a rust bds pdb dumper made by Luke7720\
    \n###############################################################*/\n"
    );

    let char_list: [char; 53] = [
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',
        's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '_', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',
        'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
    ];

    println!("{}", Yellow.paint("Generating file. Please wait..."));

    let file_path = File::open(pdb_path)?;
    let mut pdb = pdb::PDB::open(file_path)?;

    let symbol_table = pdb.global_symbols()?;
    let address_map = pdb.address_map()?;

    let mut symbols = symbol_table.iter();
    while let Some(symbol) = symbols.next()? {
        match symbol.parse() {
            Ok(pdb::SymbolData::Public(data)) if data.function => {
                let rva = data.offset.to_rva(&address_map).unwrap_or_default();
                if file_type == "txt" {
                    write!(dump_file, "{}\n{}\n\n", data.name, rva);
                } else if file_type == "hpp" {
                    let fn_id = nanoid!(10, &char_list);
                    write!(
                        dump_file,
                        "//{};\nconstexpr unsigned int {} = {};\n\n",
                        data.name, fn_id, rva
                    );
                } else {
                    break;
                }
            }
            _ => {}
        }
    }
    let _system_pause = Command::new("cmd.exe").arg("/c").arg("pause").status();

    Ok(())
}
