use {
    nanoid::nanoid,
    pdb::FallibleIterator,
    std::{fs::File, io::Write},
};

pub fn name_id() -> String {
    let char_list: [char; 53] = [
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',
        's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '_', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',
        'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
    ];

    nanoid!(10, &char_list)
}

pub fn pdb_dump(pdb_path: &str, file_type: &str, mut dump_file: File) -> pdb::Result<()> {
    write!(
        dump_file,
        "/*###############################################################\
    \nBDS function symbols and RVAs\
    \nFile generated by BDumper, a rust bds pdb dumper made by Luke7720\
    \n###############################################################*/\n"
    )
    .expect("ERROR: Could not write to file");

    let file_path = File::open(&pdb_path)?;
    let mut pdb = pdb::PDB::open(file_path)?;
    let symbol_table = pdb.global_symbols()?;
    let address_map = pdb.address_map()?;
    let mut symbols = symbol_table.iter();

    while let Some(symbol) = symbols.next()? {
        match symbol.parse() {
            Ok(pdb::SymbolData::Public(data)) if data.function => {
                let rva = data.offset.to_rva(&address_map).unwrap_or_default();

                if file_type == ".txt" {
                    write!(dump_file, "{}\n{}\n\n", data.name, rva)
                        .expect("ERROR: Could not write to file");
                } else if file_type == ".hpp" {
                    let fn_id = name_id();

                    write!(
                        dump_file,
                        "//{};\nconstexpr unsigned int {} = {};\n\n",
                        data.name, fn_id, rva
                    )
                    .expect("ERROR: Could not write to file");
                } else {
                    break;
                }
            }
            _ => {}
        }
    }
    nwg::simple_message("Completed", &format!("Completed dumping {}", pdb_path));

    Ok(())
}

pub fn find_function(pdb_path: &str, function_name: &str) -> pdb::Result<()> {
    let file_path = File::open(&pdb_path)?;
    let mut pdb = pdb::PDB::open(file_path)?;
    let symbol_table = pdb.global_symbols()?;
    let address_map = pdb.address_map()?;
    let mut symbols = symbol_table.iter();
    let mut found: bool = false;

    while let Some(symbol) = symbols.next()? {
        match symbol.parse() {
            Ok(pdb::SymbolData::Public(data)) if data.function => {
                let symbol = data.name.to_string();
                let rva = data.offset.to_rva(&address_map).unwrap_or_default();
                let function_sym: Vec<&str> = function_name.split("::").collect();
                let substr = format!("{}@{}", function_sym[1], function_sym[0]);

                if symbol.contains(&substr) {
                    nwg::simple_message(
                        "Found a match",
                        &format!(
                            "Function name: {}\nSymbol: {}\nRVA: {}",
                            function_name, data.name, rva
                        ),
                    );

                    found = true;
                    break;
                }
            }
            _ => {}
        }
    }

    if !found {
        nwg::simple_message("No matches found", "Function does not exist/was not found");
    }
    Ok(())
}
