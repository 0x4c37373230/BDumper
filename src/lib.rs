extern crate native_windows_gui as nwg;

pub mod files {
    pub fn path_exists(path: &str) -> bool {
        std::fs::metadata(path).is_ok()
    }

    pub fn create_file(file_type: &str) -> Result<std::fs::File, &str> {
        match file_type {
            ".txt" => {
                std::fs::File::create("./SymHook.txt").expect("ERROR: Could not create file");
                Ok(std::fs::OpenOptions::new()
                    .write(true)
                    .append(true)
                    .open("./SymHook.txt")
                    .unwrap())
            }
            ".hpp" => {
                std::fs::File::create("SymHook.hpp").expect("ERROR: Could not create file");
                Ok(std::fs::OpenOptions::new()
                    .write(true)
                    .append(true)
                    .open("./SymHook.hpp")
                    .unwrap())
            }
            _ => Err("Invalid File Type"),
        }
    }
}

pub mod setup {
    use {std::fs::File, crate::files, std::io::Write};

    pub fn filter_manager() -> bool {
        if !files::path_exists("./dumpFilter.txt") {
            File::create("dumpFilter.txt").unwrap();

            return false;
        }
        true
    }

    pub fn dump_init(pdb_path: &str, file_type: &str) -> Result<File, String> {
        if files::path_exists(pdb_path) == false {
            return Err(String::from(&format!("File does not exist: {}", pdb_path)));
        }

        let mut dump_file = match files::create_file(&file_type) {
            Ok(file) => file,
            Err(str) => {
                return Err(String::from(&format!("{}: {}", str, file_type)));
            }
        };

        write!(
            dump_file,
            "/*###############################################################\
        \nBDS function symbols and RVAs\
        \nFile generated by BDumper, a rust bds pdb dumper made by Luke7720\
        \n###############################################################*/\n"
        )
            .expect("ERROR: Could not write to file");

        if file_type == ".hpp" {
            write!(dump_file, "#pragma once\n").expect("ERROR: Could not write to file");
        }

        Ok(dump_file)
    }
}

pub mod pdb {
    use {
        pdb::{FallibleIterator, Rva},
        std::io::{BufRead, BufReader},
        std::{fs::File, io::Write},
    };

    pub struct BDSFunction {
        pub name: String,
        pub symbol: String,
        pub rva: Rva,
    }

    impl BDSFunction {
        fn create_instance(name: String, symbol: String, rva: Rva) -> BDSFunction {
            return BDSFunction { name, symbol, rva };
        }
    }

    pub fn pdb_dump(pdb_path: &str, file_type: &str, mut dump_file: File) -> pdb::Result<()> {
        let file_path = File::open(&pdb_path)?;
        let mut pdb = pdb::PDB::open(file_path)?;
        let symbol_table = pdb.global_symbols()?;
        let address_map = pdb.address_map()?;
        let mut symbols = symbol_table.iter();

        while let Some(symbol) = symbols.next()? {
            match symbol.parse() {
                Ok(pdb::SymbolData::Public(data)) if data.function => {
                    let rva = data.offset.to_rva(&address_map).unwrap_or_default();

                    if file_type == ".txt" {
                        write!(dump_file, "{}\n{}\n\n", data.name, rva)
                            .expect("ERROR: Could not write to file");
                    } else if file_type == ".hpp" {
                        let fn_id = md5::compute(data.name.to_string().to_string());

                        write!(
                            dump_file,
                            "//{};\nconstexpr unsigned int MD5_{:x} = {};\n\n",
                            data.name, fn_id, rva
                        )
                        .expect("ERROR: Could not write to file");
                    } else {
                        break;
                    }
                }
                _ => {}
            }
        }
        nwg::simple_message("Completed", &format!("Completed dumping {}", pdb_path));

        Ok(())
    }

    pub fn find_function(pdb_path: &str, function_name: &str) -> Result<BDSFunction, String> {
        let file_path = File::open(&pdb_path).unwrap();
        let mut pdb = pdb::PDB::open(file_path).unwrap();
        let symbol_table = pdb.global_symbols().unwrap();
        let address_map = pdb.address_map().unwrap();
        let mut symbols = symbol_table.iter();

        while let Some(symbol) = symbols.next().unwrap() {
            match symbol.parse() {
                Ok(pdb::SymbolData::Public(data)) if data.function => {
                    let symbol = data.name.to_string().to_string();
                    let rva = data.offset.to_rva(&address_map).unwrap_or_default();
                    let function_sym: Vec<&str> = function_name.split("::").collect();
                    let substr = format!("{}@{}", function_sym[1], function_sym[0]);

                    if symbol.contains(&substr) {
                        let found_function =
                            BDSFunction::create_instance(String::from(function_name), symbol, rva);
                        return Ok(found_function);
                    }
                }
                _ => {}
            }
        }

        Err(String::from(
            "Function was either not found or does not exist",
        ))
    }

    pub fn find_functions(pdb_path: &str, file_type: &str, mut dump_file: File, ) -> Result<(), String> {
        let file = File::open("./dumpFilter.txt").unwrap();
        let functions = BufReader::new(file);

        for line in functions.lines() {
            let line_ref: &str = &line.unwrap();

            if line_ref.starts_with("#") || line_ref.is_empty() {
                continue
            }

            match find_function(pdb_path, line_ref) {
                Ok(bds_func) => {
                    if file_type == ".txt" {
                        write!(dump_file, "{}\n{}\n\n", bds_func.symbol, bds_func.rva)
                            .expect("ERROR: Could not write to file");
                    } else if file_type == ".hpp" {
                        let fn_id = md5::compute(&bds_func.symbol);

                        write!(
                            dump_file,
                            "//{};\nconstexpr unsigned int MD5_{:x} = {};\n\n",
                            bds_func.symbol, fn_id, bds_func.rva
                        )
                        .expect("ERROR: Could not write to file");
                    }
                }
                Err(str) => {
                    return Err(str);
                }
            }
        }

        nwg::simple_message("Completed", &format!("Completed filtered dumping of {}", pdb_path));
        Ok(())
    }
}
